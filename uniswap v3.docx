
If virtual reserves and real reserves are overlapping each other than the liquidity in pool shall be increase by twice, isn‚Äôt it ?
‚Äî--------

2nd point
‚Äî--------------
NON-FUNGIBLE LIQUIDITY
As a result, in v3, the pool contract does not implement the ERC-20 standard. Anyone can create an ERC-20 token contract in the periphery that makes a liquidity position more fungible, but it will have to have additional logic to handle distribution of, or reinvestment of, collected fees. Alternatively, anyone could create a periphery contract that wraps an individual liquidity position (including collected fees) in an ERC-721 non-fungible token.

So it means LPTokens are erc721 which can be converted to erc20 tokens using the periphery contracts by paying the fees ? 
‚Äî------------------
A pool in Uniswap v2 stores only the most recent value of this price accumulator‚Äîthat is, the value as of the last block in which a swap occurred. When computing average prices in Uniswap v2, it is the responsibility of the external caller to provide the previous value of the price accumulator. With many users, each will have to provide their own methodology for checkpointing previous values of the accumulator, or coordinate on a shared method to reduce  costs. And there is no way to guarantee that every block in which the pool is touched will be reflected in the accumulator.

Last 2 lines
‚Äî-----------

Where does this tick spacing come from, how is it calculated ?
‚Äî----------------
Fees. Each pool is initialized with an immutable value, fee (ùõæ), representing the fee paid by swappers in units of hundredths of a basis point (0.0001%).
‚Äî----------------
Virtual liquidity me swapping fee kisko jaati he ?
‚Äî---------------
Ticks are the boundaries between discrete areas in price space. Ticks are spaced such that an increase or decrease of 1 tick represents a 0.01% (1 basis point) increase or decrease in price at any point in price space. Ticks function as boundaries for liquidity positions
‚Äî------------
ùëìùëú := ùëìùëî ‚àí ùëìùëú
What does this sign mean := ?
‚Äî------------
setPosition. The setPosition function allows a liquidity provider to update their position. Two of the arguments to setPosition ‚ÄîlowerTick and upperTick‚Äî when combined with the msg.sender, together specify a position. The function takes one additional parameter, liquidityDelta, to specify how much virtual liquidity the user wants to add or (if negative) remove
‚Äî------------
In-range liquidity refers to the liquidity contained in any positions which span both sides of the spot price.
‚Äî------------
Range orders: 
An approximation of a limit order, in which a single asset is provided as liquidity across a specified range, and is continuously swapped to the destination address as the spot price crosses the range.
‚Äî-------------
Whitepaper end
‚Äî-------------
First articles:
For concentrated liquidity to work, Uniswap has created ticks, which are used to keep liquidity within a specific price range. Every tick has its own set of liquidity provider tokens. Technically, smaller trades shouldn‚Äôt need to span more than one tick, but larger ones or those with higher slippage can encompass multiple ones, once liquidity from the initial tick is exhausted.
‚Äî-------------
Lets say there are 3 pools of pair eth/dai having 10k liquidity in each with all three price tiers i.e. 1000, 500, 3000. If i want to swap 20k dai to eth, what would happened, do i shift from 0.30% to 0.01% means this is another way how slippage works in v3 ? 
‚Äî-------------
Buy Limit Orders‚Äã
The Current price of a DAI / ETH pool is 1,500 DAI / ETH. You expect that ETH will rebound after it drops to 1,000 at the next market downturn, so you would like to place a range order swapping DAI to ETH at the price of 1,000 DAI / ETH. This is possible, as the price space below the spot price is denominated in the lower-priced asset, DAI. You can provide DAI at the price of 1,000 DAI / ETH, which will be swapped for ETH when the spot price of ETH drops past 1,000 DAI / ETH.
As the above examples show, in Uniswap V3, the two paired assets in a given pool are separated above and below the spot price, with the higher price asset available above the spot price and the lower-priced asset below.
‚Äî---------------

 As an illustration, consider the following example. Consider an ETH-USDC pool and assume the current price of ETH is 2000 USDC. Two liquidity providers ùê¥ and ùêµ both start with a position worth 1000 USDC. LP ùê¥ chooses the range [1818, 2200], while LP ùêµ chooses [1667, 2400]. According to (1), this means that they provide about 240 and 128 units of liquidity, respectively. If ETH‚Äôs price now falls to 1900, the position of LP ùê¥ will consist of 288.23 USDC and ETH worth 739.40 USDC which adds up to 967.63 USDC. LP ùêµ‚Äôs position on the other hand consists of 354.54 USDC and ETH worth 617.27 USDC, i.e. 971.81 USDC in total. In particular, the LP with the smaller interval suffered a larger loss. On the other hand, LP A earns 240/128 = 1.875 times more fees on trades occurring in the range [1818, 2200] than LP 

Qs is, how the liquidity units be calculated in scenario for A and B
‚Äî---------------
FIXED INTERVAL: For ETH-USDC pools, we choose ùëé ‚àà [0.6%, 100%] where ùëé grows in steps of 0.6%. For USDT-USDC pools, we choose ùëé ‚àà [0.1%, 50%] where ùëé grows in steps of 0.1%. We choose these values to match the precision with which LPs can choose ranges in Uniswap v3. There, the tick spacing is 60 and 10 for ETH-USDC and USDT-USDC pools, respectively. So for the latter pools, the smallest possible ratio between interval bounds is 1.000110 ‚âà 1 + 0.1%.
‚Äî---------------
What is suboptimal trading ? (something related to stable tokens pair)
‚Äî---------------
Total Volume of SWAP (Tick 7 -> Tick 9) = Volume of SWAP (Tick 7-> Tick 8) + Volume of SWAP (Tick 8 -> Tick 9)
Bob earns the percent of capital provided by Bob between ticks 7 and 8, plus the percent of capital provided by Bob between ticks 8 and 9, times the fees collected from the trade in those ranges.
‚Äî---------------
For a concrete example, let‚Äôs suppose Alice wants to provide liquidity in the DAI/ETH pool from 2000 to 4000. The exact powers using base 1.0001 to get to exactly 44.7213595 and 63.24555 (the square roots of 2000 and 4000 respectively) are not integers. The closest i‚Äôs Alice could pick would be 76013 and 82945, so Alice‚Äôs price range would actually be from 2000.035002 to 4000.142653, depending on how granular the pool allows its indexes to be (they can be further restricted to be divisible by some integer).

Qs is, how are these ticks calculated ?
‚Äî----------------------

Source: Uniswap v3 whitepaper
Here f_r means the total fees in a range defined by i_l, the lower tick, and i_u, the upper tick. It says the range‚Äôs fees are equal to the total fees generated minus the fees below (f_b) the range‚Äôs low tick and the fees above (f_a) the range's high tick.

‚Äî-------------------

With the above equation, the tick/price range can be recorded in the index form [i, i+1], instead of some crazy numbers such as 1.0001¬π‚Å∞‚Å∞ = 1.0100496621.
As each price is the multiplication of 1.0001 of the previous price, the price change is always 1.0001 ‚Äî 1 = 0.0001 = 0.01%.
For example, when i=1, p(1) = 1.0001; when i=2, p(2) = 1.00020001.
p(2) / p(1) = 1.00020001 / 1.0001 = 1.0001
See the connection between the traditional basis point 1 cent (=1% of 1$) and Uniswap v3‚Äôs basis point 0.01%?

‚Äî--------------------
Xord article:
Let's say that L is the amount of liquidity provided in position, equal to ‚àö ùëò. (it is a simple change in notation).
When the current ratio moves left concerning the current position, token0 (the amount of token0 in the pool) changes if the current ratio moves right concerning the current position, the amount of token1 changes. 

In terms of smart contracts, the assets' conversion is only done when adding or removing liquidity.

Qs: why only at adding or removing liquidity ? not wehn the swapping performs, it does change the reserves in the pool.
Using ùêø and ‚àö ùëÉ is convenient because only one of them changes at a time. Price Changes when swapping within a position; liquidity changes when moving outside of the position or when liquidity is minted or burned. 
Alternatively, liquidity can be considered the amount that token1 reserves change for a given change in ‚àö ùëÉ.
The contract needs to store information about each tick to track the amount of net liquidity that should be added or removed when the tick is crossed and track the fees earned above and below that tick.  When ticks are updated, the variables present in the tick-indexed state are updated. You can consider that after updating the global state of the contract, the pool is updating the fees collected and liquidity updated at the specific price point, which is tickUpper and tickLower.
Word boundaries are not multiple of 256
You can consider that after updating the global state of the contract, the pool is updating the fees collected and liquidity updated at the specific price point, which is tickUpper and tickLower
Swap function takes the address of the swapper (recipient), The direction of the swap, true for token0 to token1, false for token1 to token0 (zeroForOne), the amount of the swap, which implicitly configures the amount as exact input and output (amountSpecified), the value for input will be positive while negative for output.
Now, we have the accumulated fee inside a range. But, many liquidity providers may have provided different liquidity values in the same range. The token protocol owed to them will differ now.
The amount of tokens owed to LPs in a range is calculated in the positions library. This makes use of the formula.
Uncollected fee(y) = L . (feeGrowthInside - feeGrowthInsideLast)
Uncollected fee(x) = L / (1/ feeGrowthInside - 1/ feeGrowthInsideLast)
The positions are keeping track of how much fees have been earned in feeGrowthInside{0,1} the Last variable. Whereas, to calculate the latest amount of fees, the current state of ticks is used. Subtracting both values will give us the difference and increase in change. Multiplying this by the position's liquidity gives us the total uncollected fees in token0 for this position.

End of Xord article
‚Äî--------------------
TAIPAI article
‚Äî--------------------
The reason for a signed integer int instead of an uint is that negative power represents prices less than 1 but greater than 0
The concept of having a targeted price and the order will be executed after the price is crossed is exactly the concept of limit orders! The only difference is that if the range of a range order is not narrow enough, it‚Äôs highly possible that the conversion of tokens will be reverted once the price falls back to the range.
Thus, providing liquidity on v3, namely range orders, are essentially fee-earning reversible limit orders.
Calculate token Price:  https://www.publish0x.com/dalz-blog/an-example-how-uniswap-calculate-the-price-of-the-tokens-and-xvrnxjd 
TokenPrice = (100 ETH * ETH Price) / 100k TokenA
 

NOAH talk



		|-------|-------|-------|
ticks:	0		1		2		3

fake example with 1% ticks:

price @ 0th tick: 1.01**x = 1.01**0 = 1
price @ 1st tick: 1.01**x = 1.01**1 = 1.01
price @ 2nd tick: 1.01**x = 1.01**2 = 1.0201

basically limits the no. of intermediate ticks that you can add liq. at
E.g. not allwoed to add liq. at 1 so you can only add 0 or 2 , 
trade b/w 0 and 2 are basically they don;t have this fixed cost
that sassociated that crosses this 1 tick, so now 

real example with 1% ticks:
sqrt(1.0001)**x

x * y = k (L**2)

sqrt(x * y) = L



Going from 0 to 2 means a +0.20% price increment 

When the fee is 0.05% which has a tick spacing of 10, it means from first tick to second tick there are 9 empty ticks on which while swapping you easily jump and reach from first price point to the second price point.
QS: what if i created a pool of two highly volatile assets e.g. shib/sol, on a fee tier of 0.05%, what is its impact on tickspacing and swapping ?. 


Instead of tracking price which is the ratio of two assets, we are tracking the sqrt of price. sqrt(1.0001)**x. This formula lets us to track the sqrt of price


END OF NOAH TALK
‚Äî--------------------------------
ORACLES
V3 docs
Ticks are signed integers and can be expressed as a negative number, so for any circumstances where token0 is of a lower value than token1, a negative tick value will be returned by tickCumulative and a relative value of < 0 will be returned by a calculation of token0 in terms of token1.
An example of finding the price of WETH in a WETH / USDC pool, where WETH is token0 and USDC is token1:

You have an oracle reading that shows a return of tickCumulative as [70_000, 1_070_000], with an elapsed time between the observations of 10 seconds.We can derive the average tick over this interval by taking the difference in accumulator values (1_070_000 - 70_000 = 1_000_000), and dividing by the time elapsed (1_000_000 / 10 = 100_000).

With a tick reading of 100_000, we can find the value of token1 (USDC) in terms of token0 (WETH) by using the current tick as i in the formula p(i) = 1.0001**i (see 6.1 in the whitepaper).

1.0001**100_000 ‚âÖ 22015.5 USDC / WETH








DONE:
Uniswap v3 whitepaper
docs
Video tutorials (finamatics, whiteboard crypto)
https://10clouds.com/blog/defi/uniswap-v3-explained/#
https://arxiv.org/pdf/2110.01368 (revision req.)
https://credmark.com/blog/a-technical-analysis-of-uniswap-v3
https://ryanjameskim.medium.com/uniswap-v3-options-hedge-explainer-with-toy-example-part-1-52fd53ea4279 
https://ryanjameskim.medium.com/uniswap-v3-part-2-ticks-and-fee-acounting-explainer-with-toy-example-e9bf4d706884 (revision req.)
https://xord.com/research/uniswap-v3-power-to-liquidity-providers/
https://levelup.gitconnected.com/whats-new-in-uniswap-v3-a04a8f2673bb
Zero knowledge podcast https://zeroknowledge.fm/185-2/ (12 mints)
https://medium.com/taipei-ethereum-meetup/uniswap-v3-features-explained-in-depth-178cfe45f223 (revision req.)
https://medium.com/@jarekcoding/math-behind-uniswap-swap-part1-88dcc18a9612
https://medium.com/@jarekcoding/math-behind-uniswap-swap-part2-d51d6a37ce89
https://drive.google.com/file/d/1dRifSAXxc-6HKCKH8tcygEmHxJTKAlxp/view (revision  req.)
https://www.youtube.com/watch?v=XwPkXAeIppk
https://www.youtube.com/watch?v=cZ7QMmm7hJc
https://www.youtube.com/watch?v=_07eT2H_WVE
https://www.youtube.com/watch?v=nCtJ0eqaEf0







	How is tick spacing directly proportional to swap fee ? lets say alice create pool of ETH/DAI with 0.05% of swap fees then this statement would be falsify 
	
	Does x * y = k calculated after every swap takes place ? if not then how can AMM determine the real reserves ? 
